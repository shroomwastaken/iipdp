use std::collections::HashMap;
use std::fs;
use std::env;
use std::io;
use std::io::Write;
use std::process::exit;
use std::path::Path;
use iipdp;
use::std::any::Any;

fn main() {
    let args: Vec<String> = env::args().collect();

    let mut dumping: bool = false;

    if args.len() == 1 {
        println!("IIPDP v0.1 made by shroom\nUsage: iipdp <demo file> [-dump]");
        println!("-dump will output all of the available demo file information into a text file in the working directory");
        io::stdin().read_line(&mut String::new()).unwrap();
        return;
    } else if args.len() == 2  {
        println!("IIPDP v0.1 made by shroom\nFile Name: {}\n", &args[1])
    } else if args.len() == 3 && args[2] == "-dump" {
        dumping = true;
    } else {
        println!("IIPDP v0.1 made by shroom\nInvalid arguments!");
        io::stdin().read_line(&mut String::new()).unwrap();
        return;
    }
    
    let contents = fs::read(&args[1]).unwrap_or_else(|err| {
        println!(r#"Demo file reading failed because of: {} ¯\_(ツ)_/¯"#, err);
        io::stdin().read_line(&mut String::new()).unwrap();
        exit(1);
    });

    let header_info = iipdp::get_header_info(&contents);

    if header_info["DemoFileStamp"] != "HL2DEMO" {
        println!("Invalid demo file");
        io::stdin().read_line(&mut String::new()).unwrap();
        return;
    }

    let wrapped_messages = iipdp::get_messages(&contents);

    let mut sorted_keys: Vec<i32> = wrapped_messages.keys().cloned().collect();
    sorted_keys.sort();

    if !dumping {
        println!("File Stamp: {}", header_info["DemoFileStamp"]);
        println!("Demo Protocol: {}", header_info["DemoProtocol"]);
        println!("Network Protocol: {}", header_info["NetworkProtocol"]);
        println!("Server Name: {}", header_info["ServerName"]);
        println!("Client Name: {}", header_info["ClientName"]);
        println!("Map Name: {}", header_info["MapName"]);
        println!("Game Directory: {}", header_info["GameDirectory"]);
        println!("Playback Time: {}", header_info["PlaybackTime"]);
        println!("Playback Ticks: {}", header_info["PlaybackTicks"]);
        println!("Playback Frames: {}", header_info["PlaybackFrames"]);
        println!("Sign On Length: {}", header_info["SignOnLength"]);

        print!("\n");
    
        let ticks: f32 = sorted_keys[sorted_keys.len() - 2] as f32;
        let time: f32 = (&ticks + 1f32) * 0.015;

        println!("Measured Ticks: {}",  (ticks + 1f32) as i32);

        if time < 60f32 {
            println!("Measured TIme: {}", format!("{:.3}", time));
        } else {
            let minutes = (time / 60f32).floor();
            let seconds = time - (60f32 * minutes);
            println!("Measured TIme: {}", format!("{}:{:.3}", minutes, seconds));
        }
    } else {
        let mut file = fs::File::create(args[1].trim_end_matches(".dem").to_owned() + "-demo_dump.txt").unwrap_or_else( |err| {
            println!("Something went wrong when trying to create the file: {}", err);
            io::stdin().read_line(&mut String::new()).unwrap();
            exit(1);
        });

        let _ = file.write_all("Generated by IIPDP v0.1\n".as_bytes());
        let _ = file.write_fmt(format_args!("File Name: {}\n", Path::new(&args[1]).file_name().unwrap().to_str().unwrap()));
        
        if header_info["DemoProtocol"].parse::<usize>().unwrap() < 15 {
            let _ = file.write_all("Presumed game: Portal 3420\n\n".as_bytes());
        } else if header_info["DemoProtocol"].parse::<usize>().unwrap() < 15 {
            let _ = file.write_all("Presumed game: Portal Steampipe\n\n".as_bytes());
        } else {
            let _ = file.write_all("Presumed game: Portal 5135 (source unpack)\n\n".as_bytes());
        }

        let _ = file.write_all(("File Stamp: ".to_owned() + &header_info["DemoFileStamp"] + "\n").as_bytes());
        let _ = file.write_all(("Demo Protocol: ".to_owned() + &header_info["DemoProtocol"] + "\n").as_bytes());
        let _ = file.write_all(("Network Protocol: ".to_owned() + &header_info["NetworkProtocol"] + "\n").as_bytes());
        let _ = file.write_all(("Server Name: ".to_owned() + &header_info["ServerName"] + "\n").as_bytes());
        let _ = file.write_all(("Client Name: ".to_owned() + &header_info["ClientName"] + "\n").as_bytes());
        let _ = file.write_all(("Map Name: ".to_owned() + &header_info["MapName"] + "\n").as_bytes());
        let _ = file.write_all(("Game Directory: ".to_owned() + &header_info["GameDirectory"] + "\n").as_bytes());
        let _ = file.write_all(("Playback Time: ".to_owned() + &header_info["PlaybackTime"] + "\n").as_bytes());
        let _ = file.write_all(("Playback Ticks: ".to_owned() + &header_info["PlaybackTicks"] + "\n").as_bytes());
        let _ = file.write_all(("Playback Frames: ".to_owned() + &header_info["PlaybackFrames"] + "\n").as_bytes());
        let _ = file.write_all(("Sign On Length: ".to_owned() + &header_info["SignOnLength"] + "\n").as_bytes());

        let _ = file.write_all("\n".as_bytes());
        for key in sorted_keys {
            for value in &wrapped_messages[&key] {
                let cur_msg_type: usize = *value["Type"].downcast_ref::<usize>().unwrap();

                if cur_msg_type == 1 || cur_msg_type == 2 {
                    if cur_msg_type == 1 {
                        let _ = file.write_fmt(format_args!("[{}] SIGNON (1)\n", &key));
                    } else {
                        let _ = file.write_fmt(format_args!("[{}] PACKET (2)\n", &key));
                    }
                    
                    let _ = file.write_all("\tCmdInfo:\n".as_bytes());
                    let cmd_info = &value["CmdInfo"].downcast_ref::<HashMap<String, Box<dyn Any>>>().unwrap();

                    let _ = file.write_fmt(format_args!("\t\tFlags: {}\n", &cmd_info["Flags"].downcast_ref::<String>().unwrap()));

                    let _ = file.write_all("\t\tViewOrigin: ".as_bytes());
                    for i in cmd_info["ViewOrigin"].downcast_ref::<Vec<String>>().unwrap() {
                        let _ = file.write_fmt(format_args!("{} ", &i));
                    }
                    let _ = file.write_all("\n".as_bytes());

                    let _ = file.write_all("\t\tViewAngles: ".as_bytes());
                    for i in cmd_info["ViewAngles"].downcast_ref::<Vec<String>>().unwrap() {
                        let _ = file.write_fmt(format_args!("{} ", &i));
                    }
                    let _ = file.write_all("\n".as_bytes());

                    let _ = file.write_all("\t\tLocalViewAngles: ".as_bytes());
                    for i in cmd_info["LocalViewAngles"].downcast_ref::<Vec<String>>().unwrap() {
                        let _ = file.write_fmt(format_args!("{} ", &i));
                    }
                    let _ = file.write_all("\n".as_bytes());

                    let _ = file.write_all("\t\tViewOrigin2: ".as_bytes());
                    for i in cmd_info["ViewOrigin2"].downcast_ref::<Vec<String>>().unwrap() {
                        let _ = file.write_fmt(format_args!("{} ", &i));
                    }
                    let _ = file.write_all("\n".as_bytes());

                    let _ = file.write_all("\t\tViewAngles2: ".as_bytes());
                    for i in cmd_info["ViewAngles2"].downcast_ref::<Vec<String>>().unwrap() {
                        let _ = file.write_fmt(format_args!("{} ", &i));
                    }
                    let _ = file.write_all("\n".as_bytes());

                    let _ = file.write_all("\t\tLocalViewAngles2: ".as_bytes());
                    for i in cmd_info["LocalViewAngles2"].downcast_ref::<Vec<String>>().unwrap() {
                        let _ = file.write_fmt(format_args!("{} ", &i));
                    }
                    let _ = file.write_all("\n".as_bytes());

                    let _ = file.write_fmt(format_args!("\tInSequence: {}\n", &value["InSequence"].downcast_ref::<String>().unwrap()));
                    let _ = file.write_fmt(format_args!("\tOutSequence: {}\n", &value["OutSequence"].downcast_ref::<String>().unwrap()));
                    let _ = file.write_fmt(format_args!("\tData Size (bytes): {}\n", &value["Size"].downcast_ref::<usize>().unwrap()));
                    let _ = file.write_all("\tNO DATA AVAILABLE YET\n".as_bytes());
                } else if cur_msg_type == 3 {
                    let _ = file.write_fmt(format_args!("[{}] SYNCTICK (3)\n", &key));
                } else if cur_msg_type == 4 {
                    let _ = file.write_fmt(format_args!("[{}] CONSOLECMD (4)\n", &key));
                    let _ = file.write_fmt(format_args!("\tData Size (bytes): {}\n", &value["Size"].downcast_ref::<usize>().unwrap()));
                    let _ = file.write_fmt(format_args!("\tData:\n\t\t{}\n", &value["Data"].downcast_ref::<String>().unwrap()));
                } else if cur_msg_type == 5 {
                    let _ = file.write_fmt(format_args!("[{}] USERCMD (5)\n", &key));
                    let _ = file.write_fmt(format_args!("\tCmd: {}\n", &value["Cmd"].downcast_ref::<String>().unwrap()));
                    let _ = file.write_fmt(format_args!("\tData Size (bytes): {}\n", &value["Size"].downcast_ref::<usize>().unwrap()));
                    let _ = file.write_all("\tNO DATA AVAILABLE YET\n".as_bytes());
                } else if cur_msg_type == 6 {
                    let _ = file.write_fmt(format_args!("[{}] DATATABLES (6)\n", &key));
                    let _ = file.write_fmt(format_args!("\tData Size (bytes): {}\n", &value["Size"].downcast_ref::<usize>().unwrap()));
                    let _ = file.write_all("\tNO DATA AVAILABLE YET\n".as_bytes());
                } else if cur_msg_type == 7 {
                    let _ = file.write_fmt(format_args!("[{}] STOP (7)\n", &key));
                } else {
                    let _ = file.write_fmt(format_args!("[{}] STRINGTABLES (8)\n", &key));
                    let _ = file.write_fmt(format_args!("\tData Size (bytes): {}\n", &value["Size"].downcast_ref::<usize>().unwrap()));
                    let _ = file.write_all("\tNO DATA AVAILABLE YET\n".as_bytes());
                }
                let _ = file.write_all("\n".as_bytes());
            }
        }
    }

    io::stdin().read_line(&mut String::new()).unwrap();
}
