use crate::structs::datatables_manager::FlattenedProp;
use crate::structs::demo::Demo;
use crate::structs::packet::{PacketDataType, PacketType};
use crate::info_processor::net_svc_message::NetSvcMessageDataTypes;
use crate::structs::{packet_data_types as pdt, net_svc_message};
use crate::structs::cmd_info::CmdInfo;
use crate::structs::user_cmd_info::UserCmdInfo;
use crate::structs::stringtable::{write_stringtables_data_to_file, StringTableEntryDataTypes};
use crate::structs::send_table::{write_send_table_data_to_file, SendPropType};
use crate::structs::utils::{bitflags_to_string, ServerClass};
use std::path::Path;
use std::fs::{self, File};
use std::io::{Read, Write};
use std::process::exit;
use std::io;
use std::io::{Seek, SeekFrom};

pub fn print_header_info(demo: Demo) {
    println!("File Stamp:       {}", demo.header.demo_file_stamp);
    println!("Demo Protocol:    {}", demo.header.demo_protocol);
    println!("Network Protocol: {}", demo.header.network_protocol);
    println!("Server Name:      {}", demo.header.server_name);
    println!("Client Name:      {}", demo.header.client_name);
    println!("Map Name:         {}", demo.header.map_name);
    println!("Game Directory:   {}", demo.header.game_directory);
    println!("Playback Time:    {:.3}", demo.header.playback_time);
    println!("Playback Ticks:   {}", demo.header.playback_ticks);
    println!("Playback Frames:  {}", demo.header.playback_frames);
    println!("Sign On Length:   {}", demo.header.sign_on_length);

    print!("\n");

    let measured_ticks_and_time = demo.data_manager.get_measured_ticks_and_time();
    let adjusted_ticks_and_time = demo.data_manager.get_adjusted_ticks_and_time();

    println!("Measured Ticks:   {}",  (measured_ticks_and_time.0));

    if measured_ticks_and_time.1 < 60f32 {
        println!("Measured Time:    {}", format!("{:.3}", measured_ticks_and_time.1));
    } else {
        let minutes = (measured_ticks_and_time.1 / 60f32).floor();
        let seconds = (measured_ticks_and_time.1 - (60f32 * minutes)).floor();
        let millis = (measured_ticks_and_time.1 - (60f32 * minutes)).fract();
        println!("Measured Time:    {}", format!("{}:{:02}.{:.0}", minutes, seconds, millis * 1000.0));
    }

    // only print adjusted time if there were any adjustments made
    if measured_ticks_and_time != adjusted_ticks_and_time {
        println!("\nAdjusted Ticks:   {}",  (adjusted_ticks_and_time.0));

        if adjusted_ticks_and_time.1 < 60f32 {
            println!("Adjusted Time:    {}", format!("{:.3}", adjusted_ticks_and_time.1));
        } else {
            let minutes = (adjusted_ticks_and_time.1 / 60f32).floor();
            let seconds = (adjusted_ticks_and_time.1 - (60f32 * minutes)).floor();
            let millis = (adjusted_ticks_and_time.1 - (60f32 * minutes)).fract();
            println!("Adjusted Time:    {}", format!("{}:{:02}.{:.0}", minutes, seconds, millis * 1000.0));
        }
    }
}

// i should really move all of this out to their own functions
#[allow(unused)]
pub fn dump_file(file_path: &String, demo: Demo) {
    let mut file = fs::File::create(file_path.trim_end_matches(".dem").to_owned() + "-demo_dump.txt").unwrap_or_else( |err| {
        println!("Something went wrong when trying to create the file: {}", err);
        io::stdin().read_line(&mut String::new()).unwrap();
        exit(1);
    });
    
    println!("File created at: {}\n", file_path.trim_end_matches(".dem").to_owned() + "-demo_dump.txt");

    file.write_all("Generated by IIPDP v0.3.0\n".as_bytes());
    file.write_fmt(format_args!("File Name: {}\n", Path::new(&file_path).file_name().unwrap().to_str().unwrap()));
    
    if demo.header.network_protocol < 15 {
        file.write_all("Presumed game: Portal 3420\n\n".as_bytes());
    } else if demo.header.network_protocol == 24 {
        file.write_all("Presumed game: Portal Steampipe\n\n".as_bytes());
    } else if demo.header.network_protocol == 15 {
        file.write_all("Presumed game: Portal 5135 (source unpack)\n\n".as_bytes());
    }
    
    file.write_all(("File Stamp:       ".to_owned() + &demo.header.demo_file_stamp + "\n").as_bytes());
    file.write_all(("Demo Protocol:    ".to_owned() + &demo.header.demo_protocol.to_string() + "\n").as_bytes());
    file.write_all(("Network Protocol: ".to_owned() + &demo.header.network_protocol.to_string() + "\n").as_bytes());
    file.write_all(("Server Name:      ".to_owned() + &demo.header.server_name + "\n").as_bytes());
    file.write_all(("Client Name:      ".to_owned() + &demo.header.client_name + "\n").as_bytes());
    file.write_all(("Map Name:         ".to_owned() + &demo.header.map_name + "\n").as_bytes());
    file.write_all(("Game Directory:   ".to_owned() + &demo.header.map_name + "\n").as_bytes());
    file.write_all(("Playback Time:    ".to_owned() + &demo.header.playback_time.to_string() + "\n").as_bytes());
    file.write_all(("Playback Ticks:   ".to_owned() + &demo.header.playback_ticks.to_string() + "\n").as_bytes());
    file.write_all(("Playback Frames:  ".to_owned() + &demo.header.playback_frames.to_string() + "\n").as_bytes());
    file.write_all(("Sign On Length:   ".to_owned() + &demo.header.sign_on_length.to_string() + "\n").as_bytes());

    file.write_all("\n".as_bytes());
    for packet in demo.packets {
        let cur_packet_type = packet.packet_type;
        
        if cur_packet_type == PacketType::SignOn || cur_packet_type == PacketType::Packet {
            let packet_data: pdt::PP = packet.data.into();
            if cur_packet_type == PacketType::SignOn {
                file.write_fmt(format_args!("[{}] SIGNON (1)\n", &packet.tick));
            } else {
                file.write_fmt(format_args!("[{}] PACKET (2)\n", &packet.tick));
            }

            file.write_all("\tCmdInfo:\n".as_bytes());
            let cmd_info: CmdInfo = packet_data.cmd_info;

            file.write_fmt(format_args!("\t\tFlags: {}\n", bitflags_to_string(cmd_info.flags.iter_names())));

            file.write_fmt(format_args!("\t\tViewAngles:        {}\n", cmd_info.view_angles));
            file.write_fmt(format_args!("\t\tViewOrigin:        {}\n", cmd_info.view_origin));
            file.write_fmt(format_args!("\t\tLocalViewAngles:   {}\n", cmd_info.local_view_angles));
            file.write_fmt(format_args!("\t\tViewAngles2:       {}\n", cmd_info.view_angles2));
            file.write_fmt(format_args!("\t\tViewOrigin2:       {}\n", cmd_info.view_origin2));
            file.write_fmt(format_args!("\t\tLocalViewAngles2:  {}\n", cmd_info.local_view_angles2));

            file.write_fmt(format_args!("\tInSequence: {}\n", packet_data.in_sequence));
            file.write_fmt(format_args!("\tOutSequence: {}\n", packet_data.out_sequence));
            file.write_fmt(format_args!("\tData Size (bytes): {}", packet_data.size));
            net_svc_message::write_msg_data_to_file(&mut file, packet_data.messages, &demo.data_manager);
        } else if cur_packet_type == PacketType::SyncTick {
            let _ = file.write_fmt(format_args!("[{}] SYNCTICK (3)\n", packet.tick));
        } else if cur_packet_type == PacketType::ConsoleCmd {
            let packet_data: pdt::ConsoleCmd = packet.data.into();
            file.write_fmt(format_args!("[{}] CONSOLECMD (4)\n", packet.tick));
            file.write_fmt(format_args!("\tData Size (bytes): {}\n", packet_data.size));
            file.write_fmt(format_args!("\tData:\n\t\t{}\n", packet_data.data));
        } else if cur_packet_type == PacketType::UserCmd {
            let packet_data: pdt::UserCmd = packet.data.into();
            file.write_fmt(format_args!("[{}] USERCMD (5)\n", packet.tick));
            file.write_fmt(format_args!("\tCmd: {}\n", packet_data.cmd));
            file.write_fmt(format_args!("\tData Size (bytes): {}\n", packet_data.size));
            
            let user_cmd_info: UserCmdInfo = packet_data.data;

            file.write_all("\tUserCmdInfo:\n".as_bytes());
            // theres still spaghetti but this time i dont *think* theres a better way to do this
            file.write_fmt(format_args!("\t\tCommand Number: {}\n", user_cmd_info.command_number.map(|i| {i.to_string()}).unwrap_or_else(|| {"Null".to_string()})));
            file.write_fmt(format_args!("\t\tTick Count: {}\n", user_cmd_info.tick_count.map(|i| {i.to_string()}).unwrap_or_else(|| {"Null".to_string()})));

            file.write_all("\t\tView Angles: ".as_bytes());
            file.write_fmt(format_args!("{} ", user_cmd_info.view_angles_x.map(|i| {i.to_string()}).unwrap_or_else(|| {"Null".to_string()})));
            file.write_fmt(format_args!("{} ", user_cmd_info.view_angles_y.map(|i| {i.to_string()}).unwrap_or_else(|| {"Null".to_string()})));
            file.write_fmt(format_args!("{}\n", user_cmd_info.view_angles_z.map(|i| {i.to_string()}).unwrap_or_else(|| {"Null".to_string()})));

            file.write_all("\t\tMovement: ".as_bytes());
            file.write_fmt(format_args!("{} ", user_cmd_info.forward_move.map(|i| {i.to_string()}).unwrap_or_else(|| {"Null".to_string()})));
            file.write_fmt(format_args!("{} ", user_cmd_info.side_move.map(|i| {i.to_string()}).unwrap_or_else(|| {"Null".to_string()})));
            file.write_fmt(format_args!("{}\n", user_cmd_info.up_move.map(|i| {i.to_string()}).unwrap_or_else(|| {"Null".to_string()})));

            file.write_fmt(format_args!("\t\tButtons: {}\n", bitflags_to_string(user_cmd_info.buttons.iter_names())));
            file.write_fmt(format_args!("\t\tImpulse: {}\n", user_cmd_info.impulse.map(|i| {i.to_string()}).unwrap_or_else(|| {"Null".to_string()}))); 

            file.write_fmt(format_args!("\t\tWeapon Select, Subtype: {}, {}\n", user_cmd_info.weapon_select.map(|i| {i.to_string()}).unwrap_or_else(|| {"Null".to_string()}), 
                                                                                user_cmd_info.weapon_subtype.map(|i| {i.to_string()}).unwrap_or_else(|| {"Null".to_string()})));

            file.write_fmt(format_args!("\t\tMouse Dx, Dy: {}, {}\n", user_cmd_info.mouse_dx.map(|i| {i.to_string()}).unwrap_or_else(|| {"Null".to_string()}),
                                                                    user_cmd_info.mouse_dy.map(|i| {i.to_string()}).unwrap_or_else(|| {"Null".to_string()})));

        } else if cur_packet_type == PacketType::DataTables {
            let packet_data: pdt::DataTables = packet.data.into();
            file.write_fmt(format_args!("[{}] DATATABLES (6)\n", packet.tick));
            file.write_fmt(format_args!("\tData Size (bytes): {}", packet_data.size));
            file.write_fmt(format_args!("\n\t{} send tables", packet_data.send_table_count));
            for table in packet_data.send_tables {
                write_send_table_data_to_file(&mut file, table);
            }
            file.write_fmt(format_args!("\n\t{} server classes", packet_data.class_count));
            for class in packet_data.server_classes {
                file.write_fmt(format_args!("\n\t\t[{}] {} ({})", class.datatable_id, class.class_name, class.data_table_name));
            }
            file.write_all("\n".as_bytes());
            
        } else if cur_packet_type == PacketType::Stop {
            file.write_fmt(format_args!("[{}] STOP (7)\n", packet.tick));
        } else if cur_packet_type == PacketType::StringTables {
            let packet_data: pdt::StringTables = packet.data.into();
            file.write_fmt(format_args!("[{}] STRINGTABLES (8)\n", packet.tick));
            write_stringtables_data_to_file(&mut file, packet_data);
        } else if cur_packet_type == PacketType::Unknown {
            file.write_fmt(format_args!("[{}] Unknown packet type (most likely a bug)\n", packet.tick));
        }
        file.write_all("\n".as_bytes());
    }
    println!("Dumping done!");
}

#[allow(unused)]
pub fn dump_flattened_classes(file_path: &String, prop_lookup: Vec<(ServerClass, Vec<FlattenedProp>)>) {
    let mut file = fs::File::create(file_path.trim_end_matches(".dem").to_owned() + "-fc_dump.txt").unwrap_or_else( |err| {
        println!("Something went wrong when trying to create the file: {}", err);
        io::stdin().read_line(&mut String::new()).unwrap();
        exit(1);
    });
    
    println!("File created at: {}\n", file_path.trim_end_matches(".dem").to_owned() + "-fc_dump.txt");

    file.write_all("Generated by IIPDP v0.3.0\n".as_bytes());
    file.write_fmt(format_args!("File Name: {}\n", Path::new(&file_path).file_name().unwrap().to_str().unwrap()));

    for bundle in prop_lookup {
        file.write_fmt(format_args!("\n[{}] {} ({}) {} props:", bundle.0.datatable_id, bundle.0.class_name, bundle.0.data_table_name, bundle.1.len()));
        for prop in bundle.1 {
            let mut base_str: String = "                                                                                                         ".to_string();
            let prop_type_len = match prop.prop_info.send_prop_type {
                SendPropType::Int => 3,
                SendPropType::Float => 5,
                SendPropType::Vector3 | SendPropType::Vector2 => 7,
                _ => 10
            };
            
            if prop.prop_info.send_prop_type == SendPropType::Array {
                let elem = prop.array_element_prop_info.unwrap();
                let arr_str = format!("{}[{}]", Into::<&str>::into(elem.send_prop_type), prop.prop_info.num_elements.unwrap());
                base_str.replace_range(0..arr_str.len(), &arr_str);
                base_str.replace_range(15..15 + prop.name.len(), &prop.name);
                base_str.replace_range(50..55, "Low: ");
                base_str.replace_range(55..55 + elem.low_value.unwrap().to_string().len(), &elem.low_value.unwrap().to_string());
                base_str.replace_range(70..76, "High: ");
                base_str.replace_range(76..76 + elem.high_value.unwrap().to_string().len(), &elem.high_value.unwrap().to_string());
                base_str.replace_range(90..96, "Bits: ");
                base_str.replace_range(96..96 + elem.num_bits.unwrap().to_string().len(), &elem.num_bits.unwrap().to_string());
            } else {
                base_str.replace_range(0..prop_type_len, prop.prop_info.send_prop_type.clone().into());
                base_str.replace_range(15..15 + prop.name.len(), &prop.name);
                base_str.replace_range(50..55, "Low: ");
                base_str.replace_range(55..55 + prop.prop_info.low_value.unwrap().to_string().len(), &prop.prop_info.low_value.unwrap().to_string());
                base_str.replace_range(70..76, "High: ");
                base_str.replace_range(76..76 + prop.prop_info.high_value.unwrap().to_string().len(), &prop.prop_info.high_value.unwrap().to_string());
                base_str.replace_range(90..96, "Bits: ");
                base_str.replace_range(96..96 + prop.prop_info.num_bits.unwrap().to_string().len(), &prop.prop_info.num_bits.unwrap().to_string());
            }
            
            file.write_fmt(format_args!("\n\t{}", base_str));
        }
    }
}

#[allow(unused)]
pub fn verifier_dump(file_path: &String, demo: Demo, dumpfile: &Option<&File>) {
    let mut file: &File;
    let creator: File;
    if let None = dumpfile {
        // single demo
        creator = File::create(file_path.trim_end_matches(".dem").to_owned() + "-vdump.txt").unwrap_or_else( |err| {
            println!("Something went wrong when trying to create the file: {}", err);
            io::stdin().read_line(&mut String::new()).unwrap();
            exit(1);
        });
        file = &creator;
        write_dump_beginning(file, &demo);
    } else {
        file = dumpfile.unwrap();
        
        // if file is empty
        if file.seek(SeekFrom::End(0)).unwrap() == 0 {
            write_dump_beginning(file, &demo);
        }
    }

    file.write_fmt(format_args!("\n\nFile Name: {}\n", Path::new(&file_path).file_name().unwrap().to_str().unwrap()));

    let signon: &PacketDataType = &demo.packets[0].data;
    if let PacketDataType::Packet(p) = signon {
        let server_count: &NetSvcMessageDataTypes = &p.messages[0].data;
        if let NetSvcMessageDataTypes::SvcServerInfo(s) = server_count {
            file.write_fmt(format_args!("Server Count: {}\n", s.server_count));
        } else {
            println!("Couldn't find server count for whatever reason :(");
        }
    } else {
        println!("No SignOn packet found! Either iipdp is broken or the demo is bad.");
    }
    file.write_fmt(format_args!("Client Name (Header): {}\n", demo.header.client_name));
    if demo.header.network_protocol < 15 {
        file.write_all("3420 demo, no friends ID\n".as_bytes());
    } else {
        let stringtables = &demo.packets
            .iter()
            .find(|p| {p.packet_type == PacketType::StringTables})
            .expect("NO STRINGTABLES PACKET IN THIS UNPACK DEMO!!! THIS IS BAD!!!")
            .data;
        // this sucks a little bit less than before
        if let PacketDataType::StringTables(s) = &stringtables {
            let table = s.tables
                .iter()
                .find(|x| {x.name == "userinfo"}).unwrap();
            if let StringTableEntryDataTypes::PlayerInfo(pui) = &table.table_entries[0].entry_data {
                file.write_fmt(format_args!("Client Name (userinfo): {}\n", pui.name));
                file.write_fmt(format_args!("Friends ID: {}", pui.friends_id));
                if pui.name != demo.header.client_name {
                    file.write_all("\n===WARNING: CLIENT NAMES DON'T MATCH!!!===".as_bytes());
                }
            }
        }
    }
}

// just moving this out to a separate function for convenience
#[allow(unused)]
fn write_dump_beginning(mut file: &File, demo: &Demo) {
    file.write_all("Generated by IIPDP v0.3.0\n".as_bytes());
    if demo.header.network_protocol < 15 {
        file.write_all("Presumed game: Portal 3420\n\n".as_bytes());
    } else if demo.header.network_protocol == 24 {
        file.write_all("Presumed game: Portal Steampipe\n\n".as_bytes());
    } else if demo.header.network_protocol == 15 {
        file.write_all("Presumed game: Portal 5135 (source unpack)\n\n".as_bytes());
    }
}